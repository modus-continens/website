<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Sergey Mechtaev">
  <title>Modus</title>

  <link rel="stylesheet" href="assets/dist/css/hljs-vs.css">

  <!-- Bootstrap core CSS -->
  <link href="assets/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Place this tag in your head or just before your close body tag. -->

  <style>
    .bd-placeholder-img {
      font-size: 1.125rem;
      text-anchor: middle;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
    }

    @media (min-width: 768px) {
      .bd-placeholder-img-lg {
        font-size: 3.5rem;
      }
    }

    pre[class^="language-"] {
      padding: 0.5em;
      /* margin: .5em 0; */
      overflow: auto;
      border: 1px solid #dddddd;
      /* background-color: white; */
    }

    .hljs {
      background-color: transparent !important;
    }
  </style>

  <!-- Custom styles for this template -->
  <link href="modus.css" rel="stylesheet">
</head>

<body class="pb-0 mb-0">

<nav class="navbar navbar-expand-lg navbar-light modus-bg mb-0" aria-label="Modus navbar">
  <div class="container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#modusNavbar"
      aria-controls="navbarsExample07" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="modusNavbar">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
        <li class="nav-item">
          <a class="nav-link" href="https://docs.modus-continens.com">Docs</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/modus-continens/modus">GitHub</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/modus-continens/modus/issues">Issue Tracker</a>
        </li>
        <a class="nav-link" href="https://discord.gg/bXxwfVE9Kj">Discord</a>
        </li>
        </li>
        <a class="nav-link" href="https://play.modus-continens.com">Playground</a>
        </li>
      </ul>
      <a class="btn btn-outline-secondary mt-0" href="https://discord.gg/bXxwfVE9Kj" role="button">Join Community</a>
    </div>
  </div>
</nav>

<div class="modus-bg jumbotron">
  <div class="p-5">
    <div class="container">
      <div>
        <h1 class="modus-title">Modus is a language for building OCI container images</h1>

        <!-- Place this tag where you want the button to render. -->
        <a class="github-button" href="https://github.com/modus-continens/modus" data-icon="octicon-star"
          data-size="large" data-show-count="true" aria-label="Star modus-continens/modus on GitHub">Star</a>

    <div class="row mt-2">
      <div class="col-lg-8 col-md-12">
	<p class="lead">Modus uses logic programming to solve key pain points of Dockerfiles &mdash; their inability to express interactions among parameters or to specify complex build workflows, their difficult and inefficient parallelisation, bloated images, and costly maintenance.</p>

         <!-- Place this tag where you want the button to render. -->
        <p>
          <a class="btn btn-primary mt-0" href="get.html"
            role="button">Install Modus</a>
          <a class="btn btn-info mt-0" href="https://docs.modus-continens.com/tutorial.html"
            role="button">Read Tutorial</a>
        </p>
      </div>
    </div>
      </div>
    </div>
  </div>
</div>


<div>

  <div class="bg-light p-5">
    <div class="container">
      <h2 class="featurette-heading" id="parameterised-builds">Dockerfiles vs Modus</h2>
      <table class="table table-striped">
        <thead>
          <tr>
            <th scope="col"></th>
            <th scope="col">Dockerfiles</th>
            <th scope="col">Modus</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th scope="row">Parameter Interaction</th>
            <td>Do not track dependencies among build parameters.</td>
            <td>Tracks and automatically resolves dependencies among build parameters.</td>
          </tr>
          <!-- <tr> -->
          <!--   <th scope="row">Build Workflows</th> -->
          <!--   <td>Express only linear sequences of build instructions.</td> -->
          <!--   <td>Expresses custom build workflows, yet guaranteed predicable performance.</td> -->
          <!-- </tr> -->
          <tr>
            <th scope="row">Parallelisation</th>
            <td>Support custom workflows only by resorting to scripts which inefficiently parallelise.</td>
            <td>Aggressively parallelises builds involving custom logic.</td>
          </tr>
          <tr>
            <th scope="row">Image size</th>
            <td>Tend to produce both redundant layers and layers with more files and packages than required.</td>
	    <td>Avoids redundancies via its precise dependencies encoding and permits merging unnecessary layers.</td>
          </tr>
          <tr>
            <th scope="row">Maintainability</th>
            <td>Rely on hard-coded configuration and lack code reuse, so they're hard to maintain.</td>
            <td>Provides zero-cost modularity and code reuse, so they're easy to maintain.</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <div>
    <div class="p-5">
    <div class="container">
      <h2 class="featurette-heading" id="parameterised-builds">Build Parameter Dependencies</h2>
      <div class="row">
        <div class="col-lg-6 col-md-12">
          <p class="lead">Container images are intrinsically parameterised, e.g.  <code>python:3.9-slim-bullseye</code> is parameterised with Python's version <code>3.9</code> and Debian's options <code>slim</code> and <code>bullseye</code>. These parameters can, and often do, depend on and interact with each other and these interactions determine how images are built. Dockerfiles only support parameters as global variables, and do not handle dependencies between them. Developers either <a href="https://github.com/klee/klee/blob/0ba95edbad26fe70c8132f0731778d94f9609874/Dockerfile#L1-L34">hard-code version dependencies</a> or implement complex, ad-hoc Dockerfile generators. For example, <a href="https://github.com/docker-library/openjdk">Official OpenJDK Docker Images</a> use a combination of <a href="https://github.com/docker-library/openjdk/blob/20e86dbd02a19bca2f66b46bc3e8b00170f6f69c/Dockerfile-linux.template">Dockerfiles templates</a> with embedded JQ queries, <a href="https://github.com/docker-library/bashbrew/blob/1da7341a79651d28fbcc3d14b9176593c4231942/scripts/jq-template.awk">AWK scripts</a> and <a href="https://github.com/docker-library/openjdk/blob/abebf9325fea4606b9759fb3b9257ea3eef40061/apply-templates.sh">Bash scripts</a> to support parametrisation.</p>
          <p class="lead">Modus capitalises on a strong <a href="https://docs.modus-continens.com/foundations">logic progamming foundation</a> to handle parameters and their dependecies in an intuitive, declarative fashion. Modus decreased the size of build scripts for OpenJDK Docker images from 549 LoC written in three languages to 315 LoC written in a single language without sacrificing the build efficiency.</p> <p><a href="https://github.com/modus-continens/openjdk-images-case-study">OpenJDK images case study</a></p>
        </div>
        <div class="col-lg-6 col-md-12">
          <p>
            This fragment of <a href="https://github.com/docker-library/openjdk/blob/20e86dbd02a19bca2f66b46bc3e8b00170f6f69c/Dockerfile-linux.template">OpenJDK images build template</a> combines Dockerfile with two external tools: <code>{{</code> syntax handled by an AWK script, and predicates expressed as JQ queries:
            <pre><code class="language-dockerfile">
FROM {{
    if is_debian_slim then
        "debian:" + debian_suite + "-slim"
    else
        "buildpack-deps:" + debian_suite + (
        if env.javaType == "jdk" then
            "-scm"
        else
            "-curl"
        end
    )
    end
}}
            </code></pre>
            <p>An <a href="https://github.com/modus-continens/openjdk-images-case-study/blob/main/linux.Modusfile">equivalent Modusfile</a> naturally expresses this fragment without external tools:</p>
            <pre><code class="language-modusfile">
debian_image(variant, java_type) :-
    (
        is_debian_slim(variant, debian_suite),
        from(f"debian:${debian_suite}-slim")
    ;
        is_debian(variant),
        (
            java_type = "jdk",
            from(f"buildpack-deps:${variant}-scm")
        ;
            java_type = "jre",
            from(f"buildpack-deps:${variant}-curl")
        )
    ).
            </code></pre>
          </p>
        </div>
      </div>
    </div>
    </div>

<!--   <div class="bg-light p-5"> -->
<!--     <div class="container"> -->
<!--     <div class="row"> -->
<!--       <h2 class="featurette-heading" id="parallel-builds">Complex, Reproducible Workflows</h2> -->
<!--       <div class="col-lg-6 col-md-12"> -->
<!--         <p class="lead">Building software, executing CI/CD actions, or conducting empirical computer science research require defining complex, reproducible workflows, and executing them efficiently. Dockerfiles cannot express complex workflows. Modus is a general-purpose, build system agnostic tool that can containerise your workflows, make them more reproducible, and optimise via automatic caching and parallelisation.</p> -->
<!--         <p class="lead">Computer science research suffers from a <a href="https://cacm.acm.org/magazines/2020/8/246369-threats-of-a-replication-crisis-in-empirical-computer-science/fulltext">replication crisis</a>; automated program repair, an area of software engineering research, is no exception. Automated program repair experiments involve building, testing, analysing and transforming complex software projects. Modus automated experimental workflows of the well-known <a href="https://repairbenchmarks.cs.umass.edu/">ManyBugs</a> benchmark using XXX LoC, compared to YYY LoC of existing scripts, reduced experiments execution time by ZZ%, while enhancing reproducibility.</p> -->
<!--         <p><a href="https://github.com/modus-continens/program-repair-case-study">Program repair case study</a></p> -->
<!--       </div> -->
<!--       <div class="col-lg-6 col-md-12"> -->
<!--         <pre><code class="language-shell"> -->
<!-- TODO -->
<!--         </code></pre> -->
<!--       </div> -->
<!--     </div> -->
<!--       </div> -->
<!--     </div> -->

  <div class="p-5">
    <div class="container">
      <div class="row">
        <h2 class="featurette-heading" id="parallel-builds">Parallel Builds</h2>
        <div class="col-lg-6 col-md-12">
          <p class="lead">Building container images is time-consuming. Although Dockerfile builds can be automatically parallelised, using <a href="https://github.com/docker-library/openjdk/blob/20e86dbd02a19bca2f66b46bc3e8b00170f6f69c/Dockerfile-linux.template">Dockerfile generators</a> or <a href="https://github.com/containers/buildah">Buildah shell scripts</a> for defining custom logic makes parallelisation impossible or ineffective.</p>
          <p class="lead">Modus unlocks the full potential of build parallelisation by statically constructing the build graph, and using <a href="https://github.com/moby/buildkit">BuildKit</a> to agressively paralellise execution. Modus can build multiple images in parallel while maximally reusing shared layers across them.</p>
        </div>
        <div class="col-lg-6 col-md-12">
          <p>The query <code>openjdk(version, "jdk", variant), number_gt(version, 11)</code> for <a href="https://github.com/modus-continens/openjdk-images-case-study">OpenJDK Modusfile</a> builds all variants of all JDK versions greater than 11. Modus builds 23 images in parallel, reusing intermediate layers accross images:</p>
          <pre><code class="language-shell">
$ modus build . 'openjdk(version, "jdk", variant), number_gt(version, 11)'
Exporting 1/23: openjdk("17", "jdk", "bullseye") ->
sha256:220611111e8c9bbe242e9dc1367c0fa89eef83f26203ee3f7c3764046e02b248
Exporting 2/23: openjdk("17", "jdk", "slim-buster") ->
sha256:c34ce3c1fcc0c7431e1392cc3abd0dfe2192ffea1898d5250f199d3ac8d8720f
...
Exporting 23/23: openjdk("18", "jdk", "buster") ->
sha256:220611111e8c9bbe242e9dc1367c0fa89eef83f26203ee3f7c3764046e02b248
          </code></pre>
        </div>
      </div>
    </div>
  </div>

  <div class="bg-light p-5">
    <div class="container">
    <div class="row">
      <h2 class="featurette-heading" id="optimising-image-size">Optimising Image Size</h2>
      <div class="col-lg-6 col-md-12">
        <p class="lead">Container images often include redundant layers, files
	and installed packages, which greatly increases their size, slows down
	their transfer through network, and compromises security by increasing
	the attack surface. At Stackoverflow, the question <a href="https://stackoverflow.com/questions/24394243/why-are-docker-container-images-so-large"> Why are Docker container images so large?</a> has 103k views.
	Dockerfiles cannot conditionally install packages and copy files based on the build configuration, and do not provide tool for fine-grained control of layers.</p>
        <p class="lead">Modus enables the user to precisely define files and software packages required for their build configuration. Besides, Modus provides tools to reduce image size such as the operator <code>::merge</code> that merges several layers into one.</p>
      </div>
      <div class="col-lg-6 col-md-12">
        <p>The operator <code>::merge</code> is applied to a fragment of code to ensure that it will produce a single layers. As a result, the directory <code>src</code> will not be stored in an intermediate layer:</p>
        <pre><code class="language-modusfile">
app(build_mode) :-
    from("gcc:latest"),
    (
        copy("src", "src"),
        (
            build_mode = "release",
            run("cd src; make install")
        ;
            build_mode = "debug",
            run("cd src; make -e install")::in_env("CFLAGS", "-g")
        ),
        run("rm -rf src")
    )::merge.
        </code></pre>
      </div>
    </div>
      </div>
    </div>

  <div class="p-5">
    <div class="container">
    <div class="row">
      <h2 class="featurette-heading" id="modularity-and-code-reuse">Modularity & Code Reuse</h2>
      <div class="col-lg-6 col-md-12">
        <p class="lead">Just like any code, container build definitions evolve and require maintenance. Dockerfiles do not provide any tools for modularity and code reuse. Besides, to optimise image size, they require structuring code in an way that harms readability.</p>
        <p class="lead">Modus supports code evolution and maintenance by providing zero-cost modularity and code reuse. Modus allows users to define their own commands, such as layer building functions or logical predicates, to abstract reusable build workflows. Modus provides a library of builtin predicates to handle common data structures in the build logic. For example, the predicate <code>semver_geq</code> checks if the left version is greater or equal to the right version according to <a href="https://semver.org/">SemVer</a> specification.</p>
        <p><a href="https://docs.modus-continens.com/library/predicates/index.html">List of builtin predicates</a></p>
        <p class="lead">Modus provides a library of operators, such as <code>::copy</code> for <a href="https://docs.docker.com/develop/develop-images/multistage-build/"></a>multi-stage builds, that encapsulate build-specific instructions and manipulation of OCI image properties.</p>
        <p><a href="https://docs.modus-continens.com/library/operators/index.html">List of operators</a></p>
      </div>
      <div class="col-lg-6 col-md-12">
        <p>Using a user-defined predicate <code>install</code> to reuse library installation code:</p>
        <pre><code class="language-modusfile">
install(lib, version) :-
    run(f"wget https://example.com/releases/${lib}-v${version}.tar.gz && \
          tar xf ${lib}-v${version}.tar.gz && \
          mv ${lib}-v${version}/ /build"),
    run("cd /build && make install"),
    run(f"rm ${lib}-v${version}.tar.gz && \
          rm -rf /build").

app :-
    from("gcc:latest"),
    install("liba", "1.3.5"),
    install("libb", "4.1").
        </code></pre>
        <p>Using a standard library predicate <code>semver_geq</code> to compare versions of Ubuntu:</p>
        <pre><code class="language-modusfile">
base(distr_version, python_version) :-
    semver_geq(distr_version, "16.04"),
    from(f"ubuntu:${distr_version}"),
    run(f"apt-get update && apt-get install -y python${python_version} \
          && rm -rf /var/lib/apt/lists/*").
        </code></pre>
        <p>Using a standard library operator <code>::copy</code> to copy files from another build stage</p>
        <pre><code class="language-modusfile">
builder(go_version) :-
    from(f"golang:${go_version}")
        ::set_workdir("/go/src/github.com/alexellis/href-counter/"),
    run("go get -d -v golang.org/x/net/html"),
    copy("app.go", "."),
    # Executing the build command in a specific environment:
    run("go build -a -installsuffix cgo -o app .")
        ::in_env("CGO_ENABLED", "0")
        ::in_env("GOOS", "linux").

release :-
    (
        from("alpine:latest")::set_workdir("/root"),
        run("apk --no-cache add ca-certificates"),
        # Copying files from another image for multi-stage build:
        builder("1.16")::copy("/go/src/github.com/alexellis/href-counter/app", ".")
    )::set_entrypoint("./app").
        </code></pre>
      </div>
    </div>
      </div>
    </div>


  </div>

  <div class="bg-light p-5">
    <div class="container">
      <footer>
        <p>Modus is distributed under <a href="https://www.gnu.org/licenses/agpl-3.0.txt">GNU Affero General Public
            License v3.0</a>. &copy; 2022 University College London.</p>
      </footer>
    </div>
  </div>

</div>

<script src="assets/dist/js/bootstrap.bundle.min.js"></script>
<script async defer src="https://buttons.github.io/buttons.js"></script>
<script src="assets/dist/js/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script>
  for (let code of document.querySelectorAll("pre > code[class^='language-']")) {
    code.parentElement.className = code.className;
    let f = code.childNodes[0];
    // Remove empty first and last line inserted by HTML.
    if (f instanceof Text) {
      if (f.textContent.startsWith("\n")) {
        f.textContent = f.textContent.slice(1);
      }
      if (/\n\s*/m.test(f.textContent)) {
        f.textContent = f.textContent.replace(/\n\s*$/m, "")
      }
    }
  }
</script>

</body>

</html>
