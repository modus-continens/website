<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Sergey Mechtaev">
  <title>Modus</title>

	<!-- <link href="https://unpkg.com/prismjs@v1.x/themes/prism.css" rel="stylesheet" /> -->

  <link href="assets/dist/css/prism-vs.css" rel="stylesheet" />



  <!-- Bootstrap core CSS -->
  <link href="assets/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Place this tag in your head or just before your close body tag. -->

  <style>
    .bd-placeholder-img {
      font-size: 1.125rem;
      text-anchor: middle;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
    }

    @media (min-width: 768px) {
      .bd-placeholder-img-lg {
        font-size: 3.5rem;
      }
    }
  </style>

  <!-- Custom styles for this template -->
  <link href="modus.css" rel="stylesheet">
</head>

<body class="pb-0 mb-0">

<nav class="navbar navbar-expand-lg navbar-light modus-bg mb-0" aria-label="Modus navbar">
  <div class="container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#modusNavbar"
      aria-controls="navbarsExample07" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="modusNavbar">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
        <li class="nav-item">
          <a class="nav-link" href="https://docs.modus-continens.com">Docs</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/modus-continens/modus">GitHub</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/modus-continens/modus/issues">Issue Tracker</a>
        </li>
        <a class="nav-link" href="https://groups.google.com/g/modus-continens">Mailing List</a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="modus-bg jumbotron">
  <div class="p-5">
    <div class="container">
      <div>
        <h1 class="modus-title">Modus is a language for building OCI container images</h1>

        <!-- Place this tag where you want the button to render. -->
        <a class="github-button" href="https://github.com/modus-continens/modus" data-icon="octicon-star"
          data-size="large" data-show-count="true" aria-label="Star modus-continens/modus on GitHub">Star</a>

    <div class="row mt-2">
      <div class="col-lg-8 col-md-12">
        <p class="lead">Modus uses logic programming to address pain points of Dockerfiles: implementing complex build logic, parallelising builds, optimising image size, and maintaining build definitions.</p>
        <!-- Place this tag where you want the button to render. -->
        <p>
          <a class="btn btn-primary mt-0" href="https://github.com/modus-continens/modus/blob/main/GETTING_STARTED.md"
            role="button">Getting Started &raquo;</a>
        </p>
      </div>
    </div>
      </div>
    </div>
  </div>
</div>


<div>

  <div class="bg-light p-5">
    <div class="container">
      <h2 class="featurette-heading" id="parameterised-builds">Modus vs. Dockerfiles</h2>
      <table class="table table-striped">
        <thead>
          <tr>
            <th scope="col"></th>
            <th scope="col">Dockerfiles</th>
            <th scope="col">Modus</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th scope="row">Paramertisation</th>
            <td>Build parameters are global variables; their dependencies are not tracked.</td>
            <td>Parameters are local variables, their dependencies are resolved automatically.</td>
          </tr>
          <tr>
            <th scope="row">Build Logic</th>
            <td>Only linear sequences of build instructions.</td>
            <td>Custom build logic, yet guaranteed predicable performance.</td>
          </tr>
          <tr>
            <th scope="row">Parallelisation</th>
            <td>When using generators/scripts for custom logic, parallelisation is ineffective.</td>
            <td>Agressively parallelises builds involving custom logic.</td>
          </tr>
          <tr>
            <th scope="row">Image size</th>
            <td>Tend to produce redundant layers with more files and packages than required.</td>
            <td>Encodes precise dependencies to avoid redundancies; merges unnecessary layers.</td>
          </tr>
          <tr>
            <th scope="row">Maintainability</th>
            <td>Hard to maintain because of hard-coded configuration, no code reuse.</td>
            <td>Easy to maintain because of zero-cost modularity and code reuse.</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <div>
    <div class="p-5">
    <div class="container">
      <h2 class="featurette-heading" id="parameterised-builds">Parameterised Builds</h2>
      <div class="row">
        <div class="col-lg-6 col-md-12">
          <p class="lead">Container images are intrinsically parameterised, e.g. <code>python:3.9-slim-bullseye</code> is parameterised with Python's version <code>3.9</code> and Debian's options <code>slim</code> and <code>bullseye</code>. Interactions between parameters determine how images are built. Dockerfiles only support parameters as global variables, and do not handle dependencies between them. Developers either <a href="https://github.com/klee/klee/blob/0ba95edbad26fe70c8132f0731778d94f9609874/Dockerfile#L1-L34">hard-code version and dependencies</a> or implement complex, ad-hoc Dockerfile generators. For example, <a href="https://github.com/docker-library/openjdk">Official OpenJDK Docker Images</a> use a combinations of <a href="https://github.com/docker-library/openjdk/blob/20e86dbd02a19bca2f66b46bc3e8b00170f6f69c/Dockerfile-linux.template">Dockerfiles templates</a> with embedded JQ queries, <a href="https://github.com/docker-library/bashbrew/blob/1da7341a79651d28fbcc3d14b9176593c4231942/scripts/jq-template.awk">AWK scripts</a> and <a href="https://github.com/docker-library/openjdk/blob/abebf9325fea4606b9759fb3b9257ea3eef40061/apply-templates.sh">Bash scripts</a> to support parametrisation.</p>
          <p class="lead">Modus capitalises on a strong <a href="https://docs.modus-continens.com/foundations">logic progamming foundation</a> to handle parameters and their dependecies in an intuitive, declarative fashion. Modus decreased the size of build scripts for OpenJDK Docker images from 549 LoC written in three languages to 315 LoC written in a single language. Besides, Modus reduced the build time by 23% because its build model enables more effective parallelisation.</p>
          <p><a href="https://github.com/modus-continens/openjdk-images-case-study">OpenJDK images case study &raquo;</a></p>
        </div>
        <div class="col-lg-6 col-md-12">
          <p>
            This fragment of <a href="https://github.com/docker-library/openjdk/blob/20e86dbd02a19bca2f66b46bc3e8b00170f6f69c/Dockerfile-linux.template">OpenJDK images build template</a> combines Dockerfile with two external tools: <code>{{</code> syntax handled by an AWK script, and predicates expressed as JQ queries:
            <pre><code class="language-dockerfile">
FROM {{
    if is_debian_slim then
        "debian:" + debian_suite + "-slim"
    else
        "buildpack-deps:" + debian_suite + (
        if env.javaType == "jdk" then
            "-scm"
        else
            "-curl"
        end
    )
    end
}}
            </code></pre>
            <p>An <a href="https://github.com/modus-continens/openjdk-images-case-study/blob/main/linux.Modusfile">equivalent Modusfile</a> naturally expresses this fragment without external tools:</p>
            <pre><code class="language-python">
debian_image(variant, java_type) :-
    (
        is_debian_slim(variant, debian_suite),
        from(f"debian:${debian_suite}-slim")
    ;
        is_debian(variant),
        (
            java_type = "jdk",
            from(f"buildpack-deps:${variant}-scm")
        ;
            java_type = "jre",
            from(f"buildpack-deps:${variant}-curl")
        )
    ).
            </code></pre>
          </p>
        </div>
      </div>
    </div>
    </div>

  <div class="bg-light p-5">
    <div class="container">
    <div class="row">
      <h2 class="featurette-heading" id="parallel-builds">Complex, Reproducible Workflows</h2>
      <div class="col-lg-6 col-md-12">
        <p class="lead">Building software, executing CI/CD actions, or conducting empirical computer science research require defining complex, reproducible workflows, and executing them efficiently. Dockerfiles cannot express complex workflows. Modus is a general-purpose, build system agnostic tool that can containerise your workflows, make them more reproducible, and optimise via automatic caching and parallelisation.</p>
        <p class="lead">Computer science research suffers from <a href="https://cacm.acm.org/magazines/2020/8/246369-threats-of-a-replication-crisis-in-empirical-computer-science/fulltext">replication crisis</a>; automated program repair, an area of software engineering research, is not an exception. Automated program repair experiments involve building, testing, analysing and transforming complex software projects. Modus automated experimental workflows of the well-known <a href="https://repairbenchmarks.cs.umass.edu/">ManyBugs</a> benchmark using XXX LoC, compared to YYY LoC of existing scripts, reduced experiments execution time by ZZ%, while enhansing reproducibility.</p>
        <p><a href="https://github.com/modus-continens/program-repair-case-study">Program repair case study &raquo;</a></p>        
      </div>
      <div class="col-lg-6 col-md-12">
        <pre><code class="language-shell">
TODO            
        </code></pre>
      </div>
    </div>
      </div>
    </div>
    
  <div class="p-5">
    <div class="container">
      <div class="row">
        <h2 class="featurette-heading" id="parallel-builds">Parallel Builds</h2>
        <div class="col-lg-6 col-md-12">
          <p class="lead">Building container images is time-consuming. Although Dockerfile builds can be automatically parallelised, using <a href="https://github.com/docker-library/openjdk/blob/20e86dbd02a19bca2f66b46bc3e8b00170f6f69c/Dockerfile-linux.template">Dockerfile generators</a> or <a href="https://github.com/containers/buildah">Buildah shell scripts</a> for defining custom logic makes parallelisation impossible or ineffective.</p>
          <p class="lead">Modus unlocks the full potential of build parallelisation by statically constructing the build graph, and using <a href="https://github.com/moby/buildkit">BuildKit</a> to agressively paralellise execution. Modus can build multiple images in parallel while maximally reusing shared layers across them.</p>
        </div>
        <div class="col-lg-6 col-md-12">
          <p>The query <code>openjdk(version, "jdk", variant), number_gt(version, 11)</code> for <a href="https://github.com/modus-continens/openjdk-images-case-study">OpenJDK Modusfile</a> builds all variants of all JDK versions greater than 11. Modus builds 23 images in parallel, reusing intermediate layers accross images:</p>
          <pre><code class="language-shell">
$ modus build . 'openjdk(version, "jdk", variant), number_gt(version, 11)'
Exporting 1/23: openjdk("17", "jdk", "bullseye") -> 
sha256:220611111e8c9bbe242e9dc1367c0fa89eef83f26203ee3f7c3764046e02b248
Exporting 2/23: openjdk("17", "jdk", "slim-buster") ->
sha256:c34ce3c1fcc0c7431e1392cc3abd0dfe2192ffea1898d5250f199d3ac8d8720f
...
Exporting 23/23: openjdk("18", "jdk", "buster") ->
sha256:220611111e8c9bbe242e9dc1367c0fa89eef83f26203ee3f7c3764046e02b248
          </code></pre>
        </div>
      </div>
    </div>
  </div>

  <div class="bg-light p-5">
    <div class="container">
    <div class="row">
      <h2 class="featurette-heading" id="optimising-image-size">Optimising Image Size</h2>
      <div class="col-lg-6 col-md-12">
        <p class="lead">Container images often include redundant layers, files and installed packages, which greatly increases their size, slows down their transfer through network, and compromises security by increasing the attack surface. Dockerfiles cannot conditionally install packages and copy files based on the build configuration, and do not provide tool for fine-grained control of layers.</p>
        <p class="lead">Modus enables the user to precisely define files and software packages required for their build configuration. Besides, Modus provides tools to reduce image size such as the operator <code>::merge</code> that merges several layers into one.</p>
      </div>
      <div class="col-lg-6 col-md-12">
        <p>The operator <code>::merge</code> is applied to a fragment of code to ensure that it will produce a single layers. As a result, the directory <code>src</code> will not be stored in an intermediate layer:</p>
        <pre><code class="language-python">
app(build_mode) :-
    from("gcc:latest"),
    (
        copy("src", "src"),
        (
            build_mode = "release", 
            run("cd src; make install")
        ;
            build_mode = "debug",
            run("cd src; make -e install")::in_env("CFLAGS", "-g")
        ),
        run("rm -rf src")
    )::merge.
        </code></pre>
      </div>
    </div>
      </div>
    </div>

  <div class="p-5">
    <div class="container">
    <div class="row">
      <h2 class="featurette-heading" id="modularity-and-code-reuse">Modularity & Code Reuse</h2>
      <div class="col-lg-6 col-md-12">
        <p class="lead">Just like any code, container build definitions evolve and require maintenance. Dockerfiles do not provide any tools for modularity and code reuse. Besides, to optimise image size, they require structuring code in an way that harms readability.</p>
        <p class="lead">Modus supports code evolution and maintenance by providing zero-cost modularity and code reuse. Modus allows users to define their own commands, such as layer building functions or logical predicates, to abstract reusable build workflows. Modus provides a library of builtin predicates to handle common data structures in the build logic. For example, the predicate <code>semver_geq</code> checks if the left version is greater or equal to the right version according to <a href="https://semver.org/">SemVer</a> specification.</p>
        <p><a href="https://docs.modus-continens.com/library/">List of builtin predicates &raquo;</a></p>        
        <p class="lead">Modus provides a library of operators, such as <code>::copy</code> for <a href="https://docs.docker.com/develop/develop-images/multistage-build/"></a>multi-stage builds, that encapsulate build-specific instructions and manipulation of OCI image properties.</p>
        <p><a href="https://docs.modus-continens.com/library/">List of operators &raquo;</a></p>
      </div>
      <div class="col-lg-6 col-md-12">
        <p>Using a user-defined predicate <code>install</code> to reuse library installation code:</p>
        <pre><code class="language-python">
install(lib, version) :-
    run(f"wget https://example.com/releases/${lib}-v${version}.tar.gz && \
          tar xf ${lib}-v${version}.tar.gz && \
          mv ${lib}-v${version}/ /build"),
    run("cd /build && make install"),
    run(f"rm ${lib}-v${version}.tar.gz && \
          rm -rf /build").

app :-
    from("gcc:latest"),
    install("liba", "1.3.5"),
    install("libb", "4.1").
        </code></pre>
        <p>Using a standard library predicate <code>semver_geq</code> to compare versions of Ubuntu:</p> 
        <pre><code class="language-python">
base(distr_version, python_version) :-
    semver_geq(distr_version, "16.04"),
    from(f"ubuntu:${distr_version}"),
    run(f"apt-get update && apt-get install -y python${python_version} \
          && rm -rf /var/lib/apt/lists/*").
        </code></pre>
        <p>Using a standard library operator <code>::copy</code> to copy files from another build stage</p>
        <pre><code class="language-python">
builder(go_version) :-
    from(f"golang:${go_version}")
        ::set_workdir("/go/src/github.com/alexellis/href-counter/"),
    run("go get -d -v golang.org/x/net/html"),
    copy("app.go", "."),
    # Executing the build command in a specific environment:
    run("go build -a -installsuffix cgo -o app .")
        ::in_env("CGO_ENABLED", "0")
        ::in_env("GOOS", "linux").

release :-
    (
        from("alpine:latest")::set_workdir("/root"),
        run("apk --no-cache add ca-certificates"),
        # Copying files from another image for multi-stage build:
        builder("1.16")::copy("/go/src/github.com/alexellis/href-counter/app", ".")
    )::set_entrypoint("./app").
        </code></pre>
      </div>
    </div>
      </div>
    </div>
  

  </div>

  <div class="bg-light p-5">
    <div class="container">
      <footer>
        <p>Modus is distributed under <a href="https://www.gnu.org/licenses/agpl-3.0.txt">GNU Affero General Public
            License v3.0</a>. &copy; 2022 University College London.</p>
      </footer>
    </div>
  </div>

</div>

<script src="assets/dist/js/bootstrap.bundle.min.js"></script>
<script async defer src="https://buttons.github.io/buttons.js"></script>
<script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
<script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>

</body>

</html>
